function(ms_underscores_to_camel_case VarIn VarOut)
  string(REPLACE "_" ";" Pieces ${VarIn})
  foreach(Part ${Pieces})
    string(SUBSTRING ${Part} 0 1 Initial)
    string(SUBSTRING ${Part} 1 -1 Part)
    string(TOUPPER ${Initial} Initial)
    set(CamelCase ${CamelCase}${Initial}${Part})
  endforeach()
  set(${VarOut} ${CamelCase} PARENT_SCOPE)
endfunction()

function(apply_target_properties Target)
  if(ARGV1)
    set(Folder "${ARGV1}")
  endif()
  ms_underscores_to_camel_case(${Target} CamelCaseTargetName)
  set_target_properties(${Target} PROPERTIES PROJECT_LABEL ${CamelCaseTargetName} FOLDER "${Folder}")
endfunction()

macro(list_contains var value)
  set(${var})
  foreach(value2 ${ARGN})
    if(${value} STREQUAL ${value2})
      set(${var} TRUE)
    endif(${value} STREQUAL ${value2})
  endforeach()
endmacro()

function(get_lib_release_location Target LibPath)
  get_target_property(IsImported ${Target} IMPORTED)

  if(IsImported)
    set(LocationPrefix "IMPORTED_")
  endif()

  if(MSVC OR CMAKE_GENERATOR STREQUAL Xcode)
    set(LocationSuffix "_RELEASE")
  elseif(NOT ${CMAKE_BUILD_TYPE} STREQUAL Release)
    set(ErrorMessage "\n\nCMAKE_BUILD_TYPE currently set to ${CMAKE_BUILD_TYPE}. Needs to be Release.\n")
    set(ErrorMessage "${ErrorMessage} - Re-run cmake such as: cmake . -DCMAKE_BUILD_TYPE=Release")
    message(FATAL_ERROR "${ErrorMessage}")
  endif()

  if(POLICY CMP0026)
    cmake_policy(PUSH)
    cmake_policy(SET CMP0026 OLD)
  endif()
  get_target_property(CurrentLibPath ${Target} ${LocationPrefix}LOCATION${LocationSuffix})
  if(POLICY CMP0026)
    cmake_policy(POP)
  endif()

  set(${LibPath} "${CurrentLibPath}" PARENT_SCOPE)
endfunction()

function(get_dependency_paths Target HeaderPaths LibPaths)
  set(TargetsHandled ${TargetsHandled} ${Target})

  get_target_property(IncludeDirs ${Target} INTERFACE_INCLUDE_DIRECTORIES)
  if(IncludeDirs)
    set(${HeaderPaths} "${${HeaderPaths}};${IncludeDirs}")
  endif()

  get_target_property(TargetType ${Target} TYPE)
  if(NOT TargetType STREQUAL "INTERFACE_LIBRARY")
    get_lib_release_location(${Target} LibPath)
    set(${LibPaths} "${${LibPaths}};${LibPath}")

    get_target_property(CurrentLibs ${Target} INTERFACE_LINK_LIBRARIES)
    if(CurrentLibs)
      foreach(CurrentLib ${CurrentLibs})
        get_target_property(CurrentLibIncludeDirs ${CurrentLib} INTERFACE_INCLUDE_DIRECTORIES)
        if(CurrentLibIncludeDirs)
          list_contains(IsHandled ${CurrentLib} ${TargetsHandled})
          if(NOT IsHandled)
            get_dependency_paths(${CurrentLib} ${HeaderPaths} ${LibPaths})
          endif()
        else()
          get_lib_release_location(${CurrentLib} CurrentLibPath)

          if(CurrentLibPath)
            set(${LibPaths} "${${LibPaths}};${CurrentLibPath}")
          endif()
        endif()
      endforeach()
    endif()
  endif()

  set(TargetsHandled ${TargetsHandled} PARENT_SCOPE)

  string(REGEX REPLACE "^;" "" ${HeaderPaths} "${${HeaderPaths}}")
  list(REMOVE_DUPLICATES ${HeaderPaths})
  set(${HeaderPaths} "${${HeaderPaths}}" PARENT_SCOPE)

  string(REGEX REPLACE "^;" "" ${LibPaths} "${${LibPaths}}")
  set(${LibPaths} "${${LibPaths}}" PARENT_SCOPE)
endfunction()

function(format_list InList OutList)
  set(FormattedList "")
  foreach(InItem ${${InList}})
    set(FormattedList "${FormattedList}\"${InItem}\", \n")
  endforeach()
  string(REGEX REPLACE ", \n$" "" FormattedList ${FormattedList})
  set(${OutList} ${FormattedList} PARENT_SCOPE)
endfunction()